<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‡πÄ‡∏ß‡πá‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏û‡∏£‡∏µ‡πÄ‡∏°‡∏µ‡∏¢‡∏°</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
body {
  margin:0;
  font-family:'Inter', sans-serif;
  background: linear-gradient(145deg,#fdf6ff,#f0fcff);
  display:flex;
  flex-direction:column;
  height:100vh;
  overflow:hidden;
}

/* Floating Toolbar */
#toolbar {
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:10px;
  padding:12px;
  background: rgba(255,255,255,0.85);
  backdrop-filter: blur(10px);
  border-radius:20px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.15);
  position: absolute;
  top: 15px;
  left: 50%;
  transform: translateX(-50%);
  z-index:10;
  transition:0.3s;
}

/* ‡∏õ‡∏∏‡πà‡∏° Neumorphism */
#toolbar button, #toolbar input {
  padding:8px 14px;
  font-size:16px;
  border:none;
  border-radius:12px;
  cursor:pointer;
  background:#fff;
  box-shadow: 5px 5px 15px rgba(0,0,0,0.1), -5px -5px 15px rgba(255,255,255,0.7);
  transition:0.3s;
}
#toolbar button:hover, #toolbar input:hover {
  transform: translateY(-2px);
  box-shadow: 5px 5px 25px rgba(0,0,0,0.2), -5px -5px 25px rgba(255,255,255,0.85);
}
#toolbar button:active {
  transform: translateY(1px);
  box-shadow: inset 5px 5px 10px rgba(0,0,0,0.15), inset -5px -5px 10px rgba(255,255,255,0.6);
}

#canvasContainer {
  flex:1;
  overflow:hidden;
  position:relative;
}

canvas {
  background:#fff;
  display:block;
  cursor:crosshair;
  transform-origin:0 0;
  border-radius:20px;
  margin:10px auto;
  box-shadow: 0 15px 40px rgba(0,0,0,0.2);
  touch-action: none;
  transition: 0.2s;
}

/* Save button floating bottom */
#saveBtn {
  position:fixed;
  bottom:20px;
  right:20px;
  padding:12px 20px;
  border:none;
  border-radius:16px;
  background:linear-gradient(135deg,#ff9ce5,#8d5eff);
  color:#fff;
  font-weight:bold;
  box-shadow: 5px 5px 20px rgba(0,0,0,0.25);
  cursor:pointer;
  transition:0.3s;
}
#saveBtn:hover { transform: translateY(-3px); box-shadow: 5px 5px 25px rgba(0,0,0,0.35); }

@media(max-width:768px){
  #toolbar{flex-wrap:wrap;padding:8px;}
  #toolbar button, #toolbar input{font-size:14px;padding:6px 10px;}
}
</style>
</head>
<body>

<div id="toolbar">
  <button id="penBtn">üñäÔ∏è Brush</button>
  <button id="eraserBtn">ü©π Eraser</button>
  <button id="undoBtn">‚Ü©Ô∏è Undo</button>
  <button id="redoBtn">‚Ü™Ô∏è Redo</button>
  <button id="clearBtn">üóëÔ∏è Clear</button>
  Color: <input type="color" id="colorPicker" value="#ff0000">
  Size: <input type="range" id="sizePicker" min="1" max="50" value="5">
  Opacity: <input type="range" id="opacityPicker" min="0.1" max="1" step="0.1" value="1">
</div>

<div id="canvasContainer">
  <canvas id="drawingCanvas" width="2000" height="2000"></canvas>
</div>

<button id="saveBtn">üíæ Save PNG</button>

<script>
const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
let drawing=false, erasing=false;
let brushColor=document.getElementById('colorPicker').value;
let brushSize=document.getElementById('sizePicker').value;
let brushOpacity=document.getElementById('opacityPicker').value;
ctx.lineCap='round';
ctx.lineJoin='round';

// Undo/Redo
let history=[], historyStep=-1;
function saveHistory(){
  history=history.slice(0,historyStep+1);
  history.push(canvas.toDataURL());
  historyStep++;
}
function undo(){ if(historyStep>0){historyStep--; let img=new Image(); img.src=history[historyStep]; img.onload=()=>ctx.drawImage(img,0,0);}}
function redo(){ if(historyStep<history.length-1){historyStep++; let img=new Image(); img.src=history[historyStep]; img.onload=()=>ctx.drawImage(img,0,0);}}

// Draw
function startPos(e){ drawing=true; draw(e); saveHistory();}
function endPos(){ drawing=false; ctx.beginPath();}
function draw(e){
  if(!drawing) return;
  const rect = canvas.getBoundingClientRect();
  let x = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
  let y = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;
  ctx.lineWidth=brushSize;
  ctx.strokeStyle=brushColor;
  ctx.globalAlpha=erasing?1:brushOpacity;
  if(erasing) ctx.strokeStyle='#fff';
  ctx.lineTo(x/scale - offsetX/scale, y/scale - offsetY/scale);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x/scale - offsetX/scale, y/scale - offsetY/scale);
}

// Events
canvas.addEventListener('mousedown', startPos);
canvas.addEventListener('mouseup', endPos);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('touchstart', startPos);
canvas.addEventListener('touchend', endPos);
canvas.addEventListener('touchmove', draw);

// Toolbar
document.getElementById('penBtn').onclick=()=>erasing=false;
document.getElementById('eraserBtn').onclick=()=>erasing=true;
document.getElementById('clearBtn').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); saveHistory();};
document.getElementById('colorPicker').onchange=(e)=>brushColor=e.target.value;
document.getElementById('sizePicker').oninput=(e)=>brushSize=e.target.value;
document.getElementById('opacityPicker').oninput=(e)=>brushOpacity=e.target.value;
document.getElementById('undoBtn').onclick=undo;
document.getElementById('redoBtn').onclick=redo;

// Save PNG
document.getElementById('saveBtn').onclick=()=>{
  const link=document.createElement('a');
  link.download='my_drawing.png';
  link.href=canvas.toDataURL();
  link.click();
}

// Zoom / Pan
let scale=1, offsetX=0, offsetY=0, panning=false, startX=0, startY=0;
const container = document.getElementById('canvasContainer');

container.addEventListener('wheel', e=>{
  e.preventDefault();
  const zoom = e.deltaY<0?1.1:0.9;
  scale*=zoom;
  canvas.style.transform=`translate(${offsetX}px,${offsetY}px) scale(${scale})`;
});

container.addEventListener('mousedown', e=>{
  if(e.button===1){panning=true; startX=e.clientX-offsetX; startY=e.clientY-offsetY;}
});
container.addEventListener('mouseup', e=>panning=false);
container.addEventListener('mousemove', e=>{
  if(panning){offsetX=e.clientX-startX; offsetY=e.clientY-startY; canvas.style.transform=`translate(${offsetX}px,${offsetY}px) scale(${scale})`;}
});

// Pinch Zoom ‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
let lastDist=0;
container.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    lastDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
  }
});
container.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    let dist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    let zoom=dist/lastDist;
    scale*=zoom;
    lastDist=dist;
    canvas.style.transform=`translate(${offsetX}px,${offsetY}px) scale(${scale})`;
  }
});
</script>

</body>
</html>
