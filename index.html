<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‡πÄ‡∏ß‡πá‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏™‡∏°‡∏π‡∏ó + ‡∏ã‡∏π‡∏°‡πÑ‡∏î‡πâ</title>
<style>
  body {
    margin:0;
    font-family: 'Arial', sans-serif;
    background: #f0f0f0;
    display:flex;
    flex-direction:column;
    height:100vh;
    overflow:hidden;
  }
  #toolbar {
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px;
    background:#ffffff;
    box-shadow:0 2px 5px rgba(0,0,0,0.2);
    z-index:10;
  }
  #toolbar button, #toolbar input {
    padding:5px 10px;
    font-size:16px;
    border:none;
    border-radius:8px;
    cursor:pointer;
    background:#eee;
    transition:0.2s;
  }
  #toolbar button:hover, #toolbar input:hover {
    background:#ddd;
  }
  #canvasContainer {
    flex:1;
    overflow:hidden;
    position:relative;
  }
  canvas {
    background:#fff;
    display:block;
    cursor:crosshair;
    transform-origin:0 0;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button id="penBtn">üñäÔ∏è ‡πÅ‡∏õ‡∏£‡∏á</button>
  <button id="eraserBtn">ü©π ‡∏¢‡∏≤‡∏á‡∏•‡∏ö</button>
  <button id="undoBtn">‚Ü©Ô∏è Undo</button>
  <button id="redoBtn">‚Ü™Ô∏è Redo</button>
  <button id="clearBtn">üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á</button>
  ‡∏™‡∏µ: <input type="color" id="colorPicker" value="#ff0000">
  ‡∏Ç‡∏ô‡∏≤‡∏î: <input type="range" id="sizePicker" min="1" max="50" value="5">
</div>

<div id="canvasContainer">
  <canvas id="drawingCanvas" width="2000" height="2000"></canvas>
</div>

<script>
const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
let drawing=false, erasing=false;
let brushColor=document.getElementById('colorPicker').value;
let brushSize=document.getElementById('sizePicker').value;
ctx.lineCap='round';
ctx.lineJoin='round';

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Undo/Redo
let history = [];
let historyStep = -1;

function saveHistory(){
  history = history.slice(0, historyStep+1);
  history.push(canvas.toDataURL());
  historyStep++;
}

function undo(){
  if(historyStep>0){
    historyStep--;
    let img = new Image();
    img.src = history[historyStep];
    img.onload = ()=>ctx.drawImage(img,0,0);
  }
}

function redo(){
  if(historyStep<history.length-1){
    historyStep++;
    let img = new Image();
    img.src = history[historyStep];
    img.onload = ()=>ctx.drawImage(img,0,0);
  }
}

// ‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î
function startPos(e){ drawing=true; draw(e); saveHistory();}
function endPos(){ drawing=false; ctx.beginPath();}
function draw(e){
  if(!drawing) return;
  const rect = canvas.getBoundingClientRect();
  let x = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
  let y = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;
  ctx.lineWidth=brushSize;
  ctx.strokeStyle=erasing?'#fff':brushColor;
  ctx.lineTo(x/scale - offsetX/scale, y/scale - offsetY/scale);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x/scale - offsetX/scale, y/scale - offsetY/scale);
}

// Events
canvas.addEventListener('mousedown', startPos);
canvas.addEventListener('mouseup', endPos);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('touchstart', startPos);
canvas.addEventListener('touchend', endPos);
canvas.addEventListener('touchmove', draw);

// Toolbar
document.getElementById('penBtn').onclick=()=>erasing=false;
document.getElementById('eraserBtn').onclick=()=>erasing=true;
document.getElementById('clearBtn').onclick=()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  saveHistory();
};
document.getElementById('colorPicker').onchange=(e)=>brushColor=e.target.value;
document.getElementById('sizePicker').oninput=(e)=>brushSize=e.target.value;
document.getElementById('undoBtn').onclick=undo;
document.getElementById('redoBtn').onclick=redo;

// Zoom / Pan
let scale=1;
let offsetX=0;
let offsetY=0;
let panning=false;
let startX=0, startY=0;

const container = document.getElementById('canvasContainer');

container.addEventListener('wheel', e=>{
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  scale *= zoom;
  canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
});

container.addEventListener('mousedown', e=>{
  if(e.button===1){ // middle mouse for pan
    panning=true;
    startX=e.clientX - offsetX;
    startY=e.clientY - offsetY;
  }
});
container.addEventListener('mouseup', e=>panning=false);
container.addEventListener('mousemove', e=>{
  if(panning){
    offsetX=e.clientX - startX;
    offsetY=e.clientY - startY;
    canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  }
});

container.addEventListener('touchstart', e=>{
  if(e.touches.length===2){ // pinch zoom
    lastDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
});
let lastDist=0;
container.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    let dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    let zoom = dist / lastDist;
    scale *= zoom;
    lastDist = dist;
    canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  }
});
</script>

</body>
</html>
